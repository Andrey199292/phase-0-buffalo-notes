# Методы массивов

### Создание массива

- `new Array(length)` - создает новый массив через конструктор.
- `Array.from(iterableObj/array-like)` - возвращает новый массив от итерируемого объекта или псевдомассива.
- `arr.fill(value, start, end+1)` - заполняет все или указанные ячейки массива значениями. Если значением будет объект или массив, то пробросит ссылку (!). Не мутирует.

- `Array.isArray(arr)` - возвращает true, если arr является объектом класса Array, т.е. Array-сущностью, то есть массивом.

### Простые методы

- `arr.push(...items)` - добавляет в конец. Возвращает новую длину массива. Мутирует.
- `arr.pop()` - извлекает элемент с конца. Возвращает откушенный элемент. Мутирует.

- `arr.unshift(...items)` - добавляет в начало. Возвращает новую длину массива. Мутирует.
- `arr.shift()` - извлекает элемент с начала. Возвращает откушенный элемент. Мутирует.

- `arr.concat(...items)` – добавляет к массиву ...items. Если добавляется массив, тогда берутся его элементы. Возвращает новый массив. Не мутирует.

### Чуть посложнее

- `arr.slice(start, end+1)` - откусывает элементы, от start включительно до end исключительно. Возвращает откусанное. Не мутирует.

- `arr.splice(start, deleteCount, ...items)` – с индекса start удаляет deleteCount кол-во элементов и вставляет ...items, возвращает массив удаленных элементов. Мутирует.
- `arr.reverse()` – переворачивает массив, возвращает ссылку на тот же массив. Мутирует.

- `arr.toSpliced(start, deleteCount, ...items)` - то же, что и .splice, но возвращает новый массив. Не мутирует.
- `arr.toReversed()` - то же, что и .reverse, но возвращает новый массив. Не мутирует.

- `str.split(strSeparator)` - преобразует строку в массив. Не мутирует.
- `arr.join(strSeparator)` - преобразует массив в строку. Не мутирует.

- `arr.flat(level)` - убирает вложенность массивов на level глубине (от 1 до Infinity). Возвращает новый массив. Не мутирует.

### Чет тяжко

- `arr.forEach((el, index, arr) => {})` – вызывает коллбек для каждого элемента. Возвращает undefined. Не мутирует.
- `arr.map((el, index, arr) => {})` – создаёт новый массив из результатов вызова коллбека для каждого элемента. Возвращает новый массив. Не мутирует.

- `arr.indexOf(item, pos)` - ищет первый `item`, начиная с позиции `pos`, и возвращает его индекс или `-1`, если ничего не найдено. Не мутирует.
- `arr.lastIndexOf(item, pos)` – ищет последний `item`, начиная с позиции `pos`, и возвращает его индекс или `-1`, если ничего не найдено. Не мутирует.
- `arr.includes(value)` – возвращает `true`, если в массиве имеется элемент `value`, в противном случае `false`. Не мутирует.

- `arr.find((el, index, arr) => {predicate})` - применяет колбек к каждому элементу до тех пор, пока колбек не вернет true. Возвращает значение первого найденного элемента. Не мутирует.
- `arr.findIndex((el, index, arr) => {predicate})` - то же, что и .find, но возвращает индекс найденного элемента. Не мутирует.
- `arr.filter((el, index, arr) => {predicate})`  - применяет колбек к каждому элементу. Возвращает массив элементов, на которых коллбек вернул true. Не мутирует.

### Боже что это

- `arr.reduce((acc, el, index, arr) => {}, initialValue)` – вычисляет одно значение на основе всего массива, вызывая колбек для каждого элемента. Если initialValue не задан, в аккумуляторе хранится значение первого элемента. Возвращает значение acc. Не мутирует.
- `arr.reduceRight((acc, el, index, arr) => {}, initialValue)` - то же, что и .reduce, но начинает с конца. Не мутирует.

- `arr.sort((a, b) => a - b или b - a)` – сортирует массив с помощью функции сравнения. a - b - сортировка по возрастанию, b - a - сортировка по убыванию. Если функция не определена, сортирует в лексико-графическом порядке (по юникоду). Возвращает ссылку на тот же массив. Мутирует.
- `arr.toSorted((a, b) => a - b или b - a)` - то же что и .sort, но возвращает новый массив. Не мутирует.


Обратите внимание, что методы `push`, `pop`, `shift`, `unshift`, `splice`, `reverse` и `sort` мутируют исходный массив.
