# DOM - HTML + JS

## Подключение скриптов к HTML-документу

`<script defer src="путь к файлу .js"></script>`

Примечание: если использовать этот тег без defer, то инициализация остального дома не будет выполнена до момента полной загрузки скрипта. Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.

## Получение элемента (-ов)

- `document.querySelector('css-selector-name')` - вернуть первый элемент, подходящий по CSS-селектору
- `document.querySelectorAll('css-selector-name')` - вернуть все элементы по CSS-селектору в виде NodeList коллекции

- `document.getElementById('element-id')` - вернуть элемент с выбранным ID
- `document.getElementsByClassName('element-classname')` - вернуть live-NodeList коллекцию элементов. Название класса пишется без точки
- `document.getElementsByTagName('tag')` - вернуть live-NodeList коллекцию элементов

Обратите внимание на букву `s` в методах getElementById и getElement`s`ByClassName.

<details>
    <summary>Чем отличаются querySelectorAll и getElementsBy</summary>
    В основном эти два селектора отличаются временем работы и тем, что они возвращают.
    
- getElementsBy возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

В приведённом ниже примере есть два скрипта.

1. Первый создаёт ссылку на коллекцию `<div>`. На этот момент её длина равна 1.
2. Второй скрипт запускается после того, как браузер встречает ещё один `<div>`, теперь её длина – 2.
```
<div>First div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 2
</script>
```
- querySelector напротив, возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Если мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную 1
</details>
<br>
Полученные элементы можно сохранять в переменные, а потом к переменным применять эти же или следующие методы:

- `element.parentNode` - получение родительского элемента
- `element.children` - получение коллекции дочерних элементов
- `element.querySelector('css-selector-name')` - поиск первого дочернего элемента, соответствующего CSS-селектору

## Создание элемента

- `document.createElement('tag-name')` - cоздание нового HTML-элемента

Результат можно также сохранить в переменную и потом с ним работать. Созданный таким образом элемент не добавляется в DOM-дерево

- `element.append(new-element)` - добавить элемент в конец списка дочерних элементов элемента element (лол)
  **_- пока не понял чем отличается от appendChild, ДОБАВИТЬ_**

## Работа с содержимым элементов

- `element.textContent` - вернуть текстовое содержимое элемента
- `element.innerHTML` - вернуть HTML-содержимое элемента
- `element.innerText` - вернуть текстовое содержимое элемента (Чем отличается от textContent? ДОБАВИТЬ)
- `element.value` - вернуть содержимое input'а

К этим методам можно применять операторы присваивания - соответственно, оператор `=` будет заменять содержимое, а оператор `+=` добавлять.

## Работа с атрибутами элемента

- `element.setAttribute('attribute-name', 'atribute-value')` - установка значения атрибута элемента
- `element.getAttribute('attribute-name')` - вернуть значение атрибута элемента

## Работа с классами элемента

- `element.className` - возвращает название класса элемента. Может быть использовано с оператором присваивания
- `element.classList` - возвращает псевдомассив, содержащий все классы элемента. Большой брат .className
  - `element.classList.add('класс-1', 'класс-2')` - добавляет элементу новый (-ые) классы. Можно через запятую
  - `element.classList.remove('класс')` - удаляет указанный (-ые) классы
  - `element.classList.toggle('класс', boolean)` - eсли заданный класс у элемента отсутствует, то он добавляется, если такой класс есть, то класс удаляется. Когда вторым параметром передаётся false указанный класс удаляется, при передаче true - добавляется
  - `element.classList.contains('класс')` - проверяет, есть ли у элемента указанный класс. Возвращает boolean

## Работа со стилями элемента

- `element.style.*cssСвойство* = 'значение'` - применить стиль и его значение к элементу
- `element.style[css-cвойство] = 'значение'` - то же, что и выше, только для составных названий стилей
- ``` element.style.cssText = `содержимое`  ``` - добавить стили для элемента. Можно использовать сразу несколько свойств, ровно как и в CSS-файле. Обратите внимание на использование обратных кавычек

Например:

- ``` newEl.style.cssText = `
	background-color: black;
	color: white;
` ```

> Большое спасибо Viktor Yeliseyev за помощь в создании этой странички :3
